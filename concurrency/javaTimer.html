<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
<title>The Java Timer | Concurrency Deep Dives</title>    <link rel="canonical" href="https://cmhteixeira.com/concurrency/concurrency/javaTimer.html">
    <meta name="generator" content="Antora 3.0.1">
<!--<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2.6.3/dist/cdn/docsearch.css" integrity="sha256-tY3FCmL2d8yoJBOVyC2aOxdixg8sLT6CHlDWX/VUJaY=" crossorigin="anonymous">-->


<link rel="stylesheet" href="../_/stylesheets/vendor/asciinema-player.css">
<link rel="stylesheet" href="../_/stylesheets/vendor/libs.css">
<link rel="stylesheet" href="../_/stylesheets/site.css">
<link id="highlight-style-lnk" rel="stylesheet" href="../_/stylesheets/vendor/highlight-light.css">
<link rel="icon" href="../_/img/favicon.svg" type="image/x-icon">  </head>
  <body class="article">
<script src="../_/js/header-site.js"></script>
<header class="header">
  <nav class="navbar">

    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-item is-hoverable">
        <a class="navbar-link" href="">Concurrency Deep Dives</a>
      </div>
    </div>

    <div class="navbar-end" id="search-container">

      <div class="container-ml">
        <form id="singular-form-ml">
          <button class="shown-ml" type="button" id="trigger">Notify me on new articles ‚úâÔ∏è</button>
          <div id="input-container-ml">
            <input type="email" placeholder="E-mail">
            <button type="button">Send</button>
          </div>
          <div id="success-ml">Thank you!</div>
        </form>
      </div>


      <div class="theme-switch-wrapper">
        <input type="checkbox" class="checkbox" onclick="toggleDarkThemeMode(this)" id="check">
        <div class="toggle-content">
          <label class="label" for="check">
            <span>üåú</span>
            <span>üåû</span>
            <div class="ball"></div>
          </label>
        </div>
      </div>


      <button class="navbar-burger" data-target="topbar-nav-mobile">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
  </nav>

  <nav id="topbar-nav-mobile" class="navbar-menu-mobile">
    <div class="navbar-item is-hoverable">
      <a class="navbar-link" href="/concurrency/javaTimer.html">Concurrency</a>
    </div>
  </nav>
</header><div class="body">
<div class="nav-container" data-component="concurrency" data-version="master">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="javaTimer.html">Concurrency</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Timers</span>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="javaTimer.html">The Java Timer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-text">Hierarchical timer wheels üöß</span>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Data structures üöß</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">To state management üöß</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <span class="nav-text">Concurrent Maps üöß</span>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Thread communication üöß</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <span class="nav-text">Treiber Stack üöß</span>
  </li>
  <li class="nav-item" data-depth="3">
    <span class="nav-text">Priority Queue üöß</span>
  </li>
  <li class="nav-item" data-depth="3">
    <span class="nav-text">FIFO queues üöß</span>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Lower level concepts üöß</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <span class="nav-text">Mutexes and Conditional variables üöß</span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-text">Semaphores üöß</span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-text">Light switches üöß</span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-text">Barriers üöß</span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-text">Cyclic Barriers üöß</span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-text">Count-Down Latch üöß</span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-text">Futures and Promises üöß</span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-text">Lock Free Programming and CAS üöß</span>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Thread Pools üöß</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <span class="nav-text">Your average thread pool üöß</span>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-text">Work-Stealing thread pool üöß</span>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Save it forever (pdf/epub/mobi)</span>
    <span class="version">t</span>
  </div>
  <ul class="components">
    <li class="component">
      <span class="title">Java Timer</span>
      <ul class="versions">
        <li class="version">
          <a href="https://buy.stripe.com/4gw7tc42zch2czC4gg">¬£10 via Stripe</a>
        </li>
      </ul>
    </li>
  </ul>
</div>    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
    <button class="nav-toggle"></button>    <nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="javaTimer.html">Concurrency</a></li>
    <li>Timers</li>
    <li><a href="javaTimer.html">The Java Timer</a></li>
  </ul>
</nav>
    </div>
  <div class="content">
<article class="doc">


  <h1 class="page">The Java Timer</h1>
  <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>We want to study the <code>java.util.Timer</code> scheduler and strip it to its bare fundamentals. We want to know:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>How does it work?</p>
</li>
<li>
<p>What concurrency mechanisms does it use?</p>
</li>
<li>
<p>Could you roll out your own implementation, or is it some sort of native concept that ships with the java language itself and cannot be replicated in user code?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Yes. You can definitely roll out your own! Like all things concurrency, you shouldn&#8217;t use your own implementation in production, but learning to develop one from scratch is an enlightening and insightful experience.<br>
Here you will learn low level concurrency primitives and concepts which are used by the external libraries in the java world that provide us high-level concepts like timers and task schedulers.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_summary_tldr"><a class="anchor" href="#_summary_tldr"></a>Summary - TLDR</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Every <code>Timer</code> that is instantiated starts a thread. A <span class="underline">single</span> new thread.</p>
<div class="ulist">
<ul>
<li>
<p>The thread is essentially a <code>while(true)</code> loop over a queue of tasks.</p>
</li>
<li>
<p>The thread is responsible for both running the tasks, and deciding when to run the next task.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The <span class="underline">native</span> method <code>wait(&lt;timeout&gt;)</code> - present on every Java object - is the mechanism by which the thread can sleep until the next task is due.</p>
<div class="ulist">
<ul>
<li>
<p>Correspondingly, the <span class="underline">native</span>  method <code>notify()</code> is the mechanism by which the thread can be "waken up, if during its sleep," a new task is submitted that ought to run sooner.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_mvp_of_a_timer"><a class="anchor" href="#_the_mvp_of_a_timer"></a>The MVP of a <code>Timer</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The purpose of a timer is to receive and manage tasks with deferred and/or periodic execution. Given an instance, you want to give it a task "to run 1 minute from now", or "every 30 seconds."</p>
</div>
<div class="paragraph">
<p>These tasks need to run on threads, these being the basic unit to "run things". It also doesn&#8217;t make much sense to run these tasks on the same thread that submits the task. Or else the thread would have to block to process that task, which doesn&#8217;t seem useful. The question is then if we should have a single thread, multiple threads, or some kind of thread pool. Regardless, this is enough to realize that we need some kind of data structure by means of which the thread that submits the task, can actually pass the task to the thread(s) that run it.</p>
</div>
<div class="paragraph">
<p>The most basic form of a timer is therefore a lonely thread whose sole purpose is to loop over some data structure that contains tasks to run. Evidently, that data structure is shared with the other "producer" threads which have a reference to the timer and that submit the tasks:</p>
</div>
<div id="overview" class="imageblock">
<div class="content">
<img src="_images/Overview.svg" alt="Overview">
</div>
<div class="title">Figure 1. High-level representation of how a timer works internally.</div>
</div>
<div class="paragraph">
<p>It turns out, the <code>Timer</code> class is very much well represented in the above diagram. In particular, a <code>Timer</code> is associated with a <strong>SINGLE</strong> thread. Every time you create a new instance, a new thread is created. That thread goes on an infinite loop. On each iteration it checks if there is a task that it should run. It executes it if there is, and then proceeds to the next iteration. This is essentially it.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Since Java 5.0 (2004), <code>Timer</code> went out of favor with the introduction of <code>java.util.concurrent.ScheduledThreadPoolExecutor</code>. The latter is more versatile and also better designed, but <code>Timer</code> is more than adequate. For example, <code>ScheduledThreadPoolExecutor</code> is an interface rather than a concrete class, with all the advantages that brings.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Notice also that you can have many "clients" of a <code>Timer</code>. That is, many parts of your code base with a reference to the same object. Each may submit tasks, and be running on a different thread. This demands the "shared data structure" be thread-safe.</p>
</div>
<div class="sect3">
<h4 id="_the_api"><a class="anchor" href="#_the_api"></a>The API</h4>
<div class="paragraph">
<p>There are four public methods on the java&#8217;s <code>Timer</code> class.</p>
</div>
<div id="timerApi" class="exampleblock">
<div class="title">Example 1. Timer API</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Timer {
    public void schedule(TimerTask task, long delay) {/* impl */}
    public void schedule(TimerTask task, long delay, long period) {/* impl */}
    public void scheduleAtFixedRate(TimerTask task, long delay, long period) {/* impl */}
    public void cancel() {/* impl */}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>These methods are what the client threads are allowed to call.</p>
</div>
<div class="paragraph">
<p>The two methods with the <code>period</code> argument are for <strong>periodic</strong> tasks. They are meant to run "an infinite number of times" at a frequency of <code>period</code>. The difference between the two is briefly addressed towards the end of the article.<br>
We will focus on the first method. It&#8217;s the simplest, but still requiring us to address the fundamentals of the challenge that underpins timers: How to schedule the tasks.  It&#8217;s here where we lift the veil of magic. The other two scheduling methods introduce no fundamental new challenge and can be regarded as afterthoughts which we will overlook. <code>cancel()</code> is also important.</p>
</div>
<div class="paragraph">
<p>On listing <a href="#timerApi">Timer API</a>, <code>TimerTask</code> is a class which exists for the purpose of <code>Timer</code>. It is defined on the same file as well. It extends, and is essentially, a <code>Runnable</code>. It&#8217;s not overly relevant to the core understanding so we will just use <code>Runnable</code> on our case.</p>
</div>
<div class="paragraph">
<p>Keep in mind that whenever we refer to <code>Timer</code> we mean the actual java class <code>java.util.Timer</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_attempt_1_naive_approach"><a class="anchor" href="#_attempt_1_naive_approach"></a>Attempt 1 - Naive approach</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
In the code snippets that follow, we will use Scala. Scala syntax is slightly different from Java, but because all JVM languages operate within the same "concurrency model", any code and discussion is 100% "interoperable".
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We need the following:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Thread safe data structure.</p>
</li>
<li>
<p>One thread looping over that data structure endlessly.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We don&#8217;t want to have to <em>initialize</em> the timer. Once an object is created, we want it to be immediately ready to receive tasks. This means the timer&#8217;s thread will have to be created and started on the constructor call. We should pause to consider the significance of this. Even though from the point of view of the client constructing a timer looks just like any other call, underneath it is a point where the code becomes concurrent. After that point, two threads, with their own stack, are active doing their "own thing" and being scheduled on the actual physical processor. They communicate only via main memory.</p>
</div>
<details id="naiveApproach">
<summary class="title">Attempt 1 - Naive approach</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">import java.util.concurrent.{BlockingQueue, LinkedBlockingQueue}

class CustomTimer private (queue: BlockingQueue[(Runnable, Long)]) {
  def schedule(runnable: Runnable, delay: Long): Unit = {
    val task = (runnable, System.currentTimeMillis() + delay)
    queue.put(task)
  }
}

object CustomTimer {

  def apply(threadName: String): CustomTimer = {
    val queue = new LinkedBlockingQueue[(Runnable, Long)]()

    def mainLoop(): Unit =
      while (true) {
        val tuple @ (runnableTask, whenToRun) = queue.take()
        if (System.currentTimeMillis() &gt; whenToRun) runnableTask.run()
        else queue.put(tuple)
      }

    val timerThread = new Thread(new Runnable { def run(): Unit = mainLoop() })
    timerThread.setName(threadName)
    timerThread.setDaemon(false)
    timerThread.start()
    new CustomTimer(queue)
  }
}</code></pre>
</div>
</div>
</div>
</details>
<div class="paragraph">
<p>The first approach <a href="#naiveApproach">above</a> will leverage the existing <code>LinkedBlockingQueue</code> class. Developing a thread safe data structure from scratch is very educational in what regards to concurrency - which is what we want to learn - but here we will delegate that particular job so that we can focus on the other concurrency intricacies of a build a custom timer/scheduler. I will still consider that the custom timer was built "from scratch".</p>
</div>
<div class="paragraph">
<p>The listing <a href="#naiveApproach">Attempt 1 - Naive approach</a> is quite straightforward. The timer thread loops around forever. On each iteration it takes one task from the shared queue, and if that tasks' time is up, it runs it. The client threads' code path (i.e., the <code>schedule</code> method) is even simpler. It is just a thin wrapper to inserting tasks onto the same shared queue.</p>
</div>
<div class="paragraph">
<p>Are you surprised of the usage of <code>System.currentTimeMillis()</code> to help schedule the tasks? Don&#8217;t be. <code>Timer</code> uses the exact same mechanism to determine when a task needs to run.<br>
This actually makes both <code>Timer</code> and our custom timer sensitive to the user changes of the system time. That is, if you schedule a task to run 1 hour from now, and then you change the clock back 1 year, the task will take 1 year and 1 hour to start running. Some consider this a "tiny" bug, others a feature. In contrast, the <code>ScheduledThreadPoolExecutor</code> uses <code>System.nanoTime()</code> that does not suffer from this.</p>
</div>
<div class="paragraph">
<p>For all its cons, an advantage of this approach is that the thread will not waste CPU time when there are no tasks submitted. This is provided by blocking queue, which puts the thread calling <code>queue.take</code> on a "waiting" state until a timer client pushes a new element/task to the queue.</p>
</div>
<div class="paragraph">
<p>We can see that by profiling the thread state:</p>
</div>
<details>
<summary class="title">spin method. Useful for tests. Used throughout.</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">import scala.concurrent.duration._

def spin(duration: Duration): Unit = {
  val stopSpinning = System.currentTimeMillis() + duration.toMillis
  while (System.currentTimeMillis() &lt; stopSpinning) {}
}</code></pre>
</div>
</div>
</div>
</details>
<details id="threadSleepsWhenQueueEmpty">
<summary class="title">Thread "sleeps" when queue is empty</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">import scala.concurrent.duration._

object SomeTests extends App {
  val customTimer = CustomTimer("FooBarThread") <i class="conum" data-value="1"></i><b>(1)</b>

  spin(1.minute) <i class="conum" data-value="2"></i><b>(2)</b>

  customTimer.schedule(
    new Runnable { def run(): Unit = spin(20.seconds) },
    30.second.toMillis
  )

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>By the time this constructor returns, the timer thread is already up and running.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Note, this call happens on the main thread, which is different from the timer thread.</td>
</tr>
</table>
</div>
</div>
</details>
<div class="imageblock">
<div class="content">
<img src="_images/TimerThreadLane-Attempt1.svg" alt="TimerThreadLane Attempt1">
</div>
<div class="title">Figure 2. States of the timer thread for the listing <a href="#threadSleepsWhenQueueEmpty">Thread "sleeps" when queue is empty</a>. No tasks on the queue, means the thread will be in a waiting state, whereby the CPU will not run it.</div>
</div>
<div class="paragraph">
<p>The biggest disadvantage of this attempt is that when there are pending tasks (i.e. the queue is not empty) the timer thread is needlessly active. The thread will be assigned CPU time, although nothing  of value is running until the next task has to be run: If you submit a single task to run 30 minutes from now, for the next 30 minutes, the thread will be continuously looping around.</p>
</div>
<div class="paragraph">
<p>There is an implicit requirement:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>The timer thread should not waste CPU cycles <strong>UNTIL</strong> the time for the next task to run expires.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>This is indeed what <code>Timer</code> does. The diagram shows what the timer thread is doing for the listing <a href="#twoTasksScheduled">Scheduling of two tasks</a>.</p>
</div>
<details id="twoTasksScheduled">
<summary class="title">Scheduling of two tasks</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">import java.util.{Timer, TimerTask}
import scala.concurrent.duration._

object SomeTests extends App {

  val javaTimer = new Timer("FooBarTimer") <i class="conum" data-value="1"></i><b>(1)</b>

  javaTimer.schedule(
    new TimerTask { def run() = spin(20.second) },
    30.second.toMillis
  )

  javaTimer.schedule(
    new TimerTask { def run() = spin(20.second) },
    90.second.toMillis
  )
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>By the time this constructor returns, the timer thread is already up and running.</td>
</tr>
</table>
</div>
</div>
</details>
<div id="javaTimerTwoTasksScheduled" class="imageblock">
<div class="content">
<img src="_images/TimerThreadLane.svg" alt="TimerThreadLane">
</div>
<div class="title">Figure 3. States of the thread of a <code>java.util.Timer</code> for the listing <a href="#twoTasksScheduled">Scheduling of two tasks</a>.</div>
</div>
<div class="paragraph">
<p>The timer (and therefore associated thread) is created at around time 0, and immediately after two tasks are submitted. Task 1, schedule to run 30 seconds from now and Task 2, schedule to run 90 seconds from now. Both tasks are just a while loop for 20 seconds.</p>
</div>
<div class="paragraph">
<p><strong>Importantly note</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>For the first 30 seconds, there is nothing to do. Adequately the thread sleeps and does not wast CPU. "It knows" exactly when to wake back up.</p>
</li>
<li>
<p>After it runs Task 1, it goes back to idle until Task 2 is meant to run.</p>
</li>
<li>
<p>After running Task 2, as there are no more tasks submitted, it correctly goes back to a "Waiting state".</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_attempt_2"><a class="anchor" href="#_attempt_2"></a>Attempt 2</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We could try to improve our custom <a href="#_attempt_1_naive_approach">Attempt 1 - Naive approach</a>, by calling <code>Thread.sleep(&lt;duration&gt;)</code>, where <code>duration</code> would be the time interval until the next task is meant to run. That is, on each iteration we take the task which should run next, and then put the thread to sleep until that task should run; when it wakes, the thread then runs it, and moves on to the next iteration.<br>
The problem is we would miss-schedule tasks the clients submit <span class="underline">after</span> the timer thread goes to the sleep state.</p>
</div>
<div class="paragraph">
<p>In other words, the question is:</p>
</div>
<div class="paragraph">
<p>Relative to the previous <a href="#javaTimerTwoTasksScheduled">scenario</a>, what would happen if some client - on a different thread - submitted a task <strong>at</strong> 60 seconds, when the timer thread was waiting to run Task 2, and such that this new task has a scheduled time of 10 seconds (meaning, it should run at time 70 seconds)?</p>
</div>
<div class="paragraph">
<p>Sadly, in our purposed approach with <code>Thread.sleep()</code>, the timer would run Task 3 at best at 90 seconds, once it awakens.</p>
</div>
<div class="paragraph">
<p>By contrast, the <code>Timer</code> correctly wakes up prematurely, and is able to run Task 3 <strong>before</strong> Task 2:</p>
</div>
<details id="submitNewTaskWhenThreadIsWaitingForAnother">
<summary class="title">Submitting a task due sooner</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">import java.util.{Timer, TimerTask}
import scala.concurrent.duration._

object SomeTests extends App {

  val javaTimer = new Timer("FooBarTimer") <i class="conum" data-value="1"></i><b>(1)</b>

  javaTimer.schedule(
    new TimerTask { def run() = spin(20.second) },
    30.second.toMillis
  )

  javaTimer.schedule(
    new TimerTask { def run() = spin(20.second) },
    90.second.toMillis
  )

  spin(60.seconds) <i class="conum" data-value="2"></i><b>(2)</b>

  javaTimer.schedule(
    new TimerTask { def run() = spin(10.second) },
    10.second.toMillis
  )
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>By the time this constructor returns, the timer thread is already up and running.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Notice that this is the main thread, the only "client" of the <code>Timer</code> instance.</td>
</tr>
</table>
</div>
</div>
</details>
<div class="imageblock">
<div class="content">
<img src="_images/TimerThreadLane-ExtraTask.svg" alt="TimerThreadLane ExtraTask">
</div>
<div class="title">Figure 4. States of the timer thread of a <code>java.util.Timer</code> for the listing <a href="#submitNewTaskWhenThreadIsWaitingForAnother">Submitting a task due sooner</a>.</div>
</div>
<div class="paragraph">
<p>Furthermore, notice the dashed line at 60 seconds, when Task 3 is introduced? If we were to zoom-in, we would notice that the thread wakes up for a very brief period of time, in the order of microseconds. This is necessary off course to verify when the new Task 3 has to be run and take appropriate action.</p>
</div>
<div class="paragraph">
<p>This seems rather magical. The timer thread, which is effectively not running when Task 3 is submitted, wakes up as a result of the submission and then 1) processes the new task, 2) understands it should run earlier than Task 2, and 3) goes back to sleep until its <span class="underline">new</span> due date.</p>
</div>
<div class="paragraph">
<p>This is off course what you would intuitively expect. We should augment the previous requirement.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>The timer thread should not waste CPU time <strong>UNTIL</strong> the time for the next task to run expires, <strong>OR UNTIL</strong> a new task is submitted in the meantime, such that it has to run before the former.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Solving this problem requires us to use low level concepts. The same concepts that external libraries that provide us with higher-level abstractions for concurrency, as for example the akka project, use.<br>
And this is in fact the point. We want to explore the most basic concurrency building blocks in Java. The building blocks that all other libraries, no matter how esoteric, must ultimately use.</p>
</div>
<div class="paragraph">
<p>It is here that the interface between our source code (be it Java/Scala/Kotlin) and the underlying system (JVM, OS, Hardware) occurs.<br>
The same way you ultimately need the JVM to have native code to handle the file system, or network calls for us, here we must also rely on the JVM to be able to deal with thread scheduling.<br>
In turn, the JVM will call the underlying OS for this, given that threads is primarily an OS abstraction</p>
</div>
<div class="paragraph">
<p>What is exposed by the JVM are the native methods <code>wait()</code>, <code>wait(&lt;timeout&gt;)</code>, and <code>notify()</code>. These methods work alongside and are strictly associated with intrinsic locks. These are also called java monitors or <code>synchronized</code> blocks.<br>
Most likely, some readers are already familiar with these.They exist on every Java object, and are one of the pillars of all things concurrency in Java. The other pillar being atomics.</p>
</div>
<div class="paragraph">
<p>We won&#8217;t be exploring these methods in detail. That requires an article of its own, but a summary is important.</p>
</div>
<div class="paragraph">
<p>The most important method/keyword is <code>synchronized</code>. Synchronized is the syntax to implement java monitors (or intrinsic locks). This is essentially the java version of a mutex. Any and all Java objects, even the ones associated with your own classes, have this method. Any code <strong>within</strong> a <code>synchronized</code> block is guaranteed to be accessed at most by one thread at a given time. Meaning, no two threads can be "inside" that code simultaneously. We say that only a given thread can have the monitor for a given object at a given time.<br>
Equally important, the <code>wait()</code> and <code>notify()</code> methods above exist within the context of a <span class="underline">particular</span> monitor. Not outside. Meaning, calling those methods can only occur with the monitor held. Any other behaviour throws an exception.<br>
When the thread holding the monitor of an object calls <code>wait()</code> (or <code>wait(&lt;timeout&gt;)</code>), the thread <strong>releases</strong> the monitor and goes to a waiting state. In this state, the OS will not give CPU cycles for it to run. The thread is only awaken when another thread calls <code>notify()</code> on the same object, or the timeout expires.<br>
Similarly, calling <code>notify()</code> can only be done when the thread is holding the monitor of the same object. This method then releases the monitor, and it awakes one thread that is waiting. If there are many waiting on that monitor, "it selects" one thread at random.<br>
Again, for both methods, the thread must have already acquired the monitor. Meaning those calls are normally inside <code>synchronized</code> blocks.</p>
</div>
<div class="paragraph">
<p>With them, we are able to meet the requirement above.</p>
</div>
<details id="firstSeriousSolution">
<summary class="title">A serious solution</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">import java.util.Comparator
import java.util.concurrent.{BlockingQueue, PriorityBlockingQueue}

class CustomTimer private (lock: Object, queue: BlockingQueue[(Runnable, Long)]) {
  def schedule(runnable: Runnable, delay: Long): Unit = {
    val thisTask = (runnable, System.currentTimeMillis() + delay)
    queue.put(thisTask)
    if (queue.peek() == thisTask) {
      lock.synchronized {
        lock.notify() <i class="conum" data-value="1"></i><b>(1)</b>
      }
    }
  }
}

object CustomTimer {

  private def comparator: Comparator[(Runnable, Long)] =  <i class="conum" data-value="2"></i><b>(2)</b>
    new Comparator[(Runnable, Long)] {
      def compare(o1: (Runnable, Long), o2: (Runnable, Long)): Int =
        (o1._2 - o2._2).toInt
    }

  def apply(threadName: String): CustomTimer = {
    val lock: Object = new Object()
    val queue = new PriorityBlockingQueue[(Runnable, Long)](10, comparator)

    def mainLoop(): Unit =
      while (true) {
        val tuple @ (runnableTask, whenToRun) = queue.take()
        val timeToWait = whenToRun - System.currentTimeMillis()
        if (timeToWait &lt;= 0) runnableTask.run()
        else {
          lock.synchronized {
            lock.wait(timeToWait) <i class="conum" data-value="1"></i><b>(1)</b>
          }
          queue.offer(tuple)
        }
      }

    val timerThread = new Thread(new Runnable { def run(): Unit = mainLoop() })
    timerThread.setName(threadName)
    timerThread.setDaemon(false)
    timerThread.start()
    new CustomTimer(lock, queue)
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>notify</code> and <code>wait</code> calls "dance" together.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>PriorityBlockingQueue</code> needs this to be able to sort the elements by priority.</td>
</tr>
</table>
</div>
</div>
</details>
<div class="paragraph">
<p>The <code>lock</code> object serves only the purpose of being the monitor for the <code>synchronized</code>/<code>wait</code>/<code>notify</code> calls. Obviously the actual name of the variable is not important. Since these methods are available on any and all java objects, the most appropriate object is simply <code>new Object()</code>.</p>
</div>
<div class="paragraph">
<p>As on <a href="#naiveApproach">Attempt 1 - Naive approach</a> we delegate the responsibility of maintaining state - in a thread safe way - to an external queue implementation. <code>PriorityBlockingQueue</code> used here has the extra advantage of sorting the tasks that we provide by priority, where priority is defined by the <code>Comparator</code> object. So when we call <code>queue.take()</code>, we are guarantee to take the next task that should run.<br>
Developing such queue would also very insightful onto concurrency concepts. But again, here we are focusing on other aspects. If we were really adamant about developing everything from scratch, we could have easily, as the simplest scenario, just have used a linked list with external synchronization via the <code>synchronized</code> block to serve as a queue. It would not be a very good implementation, but it would work.</p>
</div>
<div class="paragraph">
<p><code>Timer</code> also leverages the same essential mechanism and the <code>synchronized</code>/<code>wait</code>/<code>notify</code> triad to schedule tasks. However, it doesn&#8217;t use a separate object to act as the monitor. Instead, it uses the queue itself. In other words it doesn&#8217;t strictly separate the responsibility of the data structure from the scheduling part. This works for <code>Timer</code> as it uses a queue specially made for the timer. It is on the same file on the <code>java.util</code> package and was designed with that in mind. In our case, as we use an external queue, we don&#8217;t want to call synchronize methods on it. That would make things harder to understand, and more importantly, it would increase contention on the queue.  In other words, why use an external queue to which we delegate thread safety, if we then end up using explicit external locking (via synchronize)?</p>
</div>
<div class="paragraph">
<p>On listing <a href="#firstSeriousSolution">A serious solution</a>, the <code>lock.notify()</code> and <code>lock.wait(&lt;timeout&gt;)</code> calls should be analyzed together. They perform a sort of dance.<br>
On the timer&#8217;s thread side, <code>lock.wait(&lt;timeout&gt;)</code> puts the thread in a waiting state - what we want. it solves <strong>both</strong> problems. It will wake up either when the timeout expires, or when some other thread calls <code>notify()</code> (or <code>notifyAll()</code>) on that same object <code>lock</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see how our custom solution deals with example <a href="#submitNewTaskWhenThreadIsWaitingForAnother">Submitting a task due sooner</a>. The starting point shall be when the timer thread is already executing Task 1. At that moment, Task 2 is already on the queue, but Task 3 is not.<br>
Once the timer thread finishes Task 1, it begins another iteration of the loop. It removes Task 2 (at that point the only task left) and falls into the <code>else</code> branch as it&#8217;s time is not up yet. It enters the <code>synchronized</code> block and calls the wait method with timeout <code>90s-50s=30s</code>. At this point the timer thread goes into the waiting state. As discussed earlier, this means that the JVM/OS will a) prevent that thread from obtaining CPU scheduling time, and 2) "take note" that the thread should wake up once the monitor in which it is waiting gets notified, or the timeout expires. Whichever comes first.<br>
At same point later, but before those 30 seconds go by, the timer thread is still asleep when a client, on another thread, submits a new task. Because this new task is the next task to run (being it the only one on the queue), our <code>schedule</code> method will enter the <code>if</code> block. There, it acquires the lock. This is possible, because the timer thread relinquished the lock earlier, when it called <code>wait(30s)</code>. With the monitor lock held, it calls <code>lock.notify()</code>. This has the power to wake up the timer thread. Recall that by the semantics of <code>Object.wait()</code>, the thread wakes up when the timeout expires where when some other thread calls <code>notify</code>.<br>
After the timer thread awakens, it continues where it left off. After exiting the synchronized block, it inserts the Task 2 back into the shared queue, and then starts another loop iteration. At the point it takes an element from the queue, both tasks Task 2 and Task 3 will be present there. The one taken is the one that ought to run first. Recall that the responsibility of sorting the queue according with schedule time was deferred to the <code>java.util.concurrent.PriorityBlockingQueue</code> (for convenience only; as said there is nothing magical about this). Because of this, Task 3 will be the one removed from the queue. Still, it is not yet the time for the task to run. So we go again onto the <code>else</code> branch and call <code>lock.wait(10 seconds)</code>. Because for this example there are no more clients submitting tasks, there is no more calls to <code>lock.notify()</code> through the <code>schedule</code> method, and the only way for the timer thread to wake up is when the timeout expires.<br>
After it wakes up, it runs the task. Well, not immediately. In this implementation we first offer it back to the queue. That&#8217;s fine, because the thread now begins another iteration of the loop, and it will take the same Task 3 again. By then <code>timeToWait</code> will be negative and finally Task 3 is run. After Task 3 completes, we are back again on a new iteration. By now, only Task 2 remains on the queue, and the process repeats itself.</p>
</div>
<div class="paragraph">
<p>Lastly, notice that if instead clients insert new tasks which are not scheduled to run after the next one, then the timer thread will not be awakened (in case it was waiting).</p>
</div>
<div class="paragraph">
<p>There you have it. A bare-bones implementation of a timer using the same scheduling mechanism as the actual <code>Timer</code> class. For the purposes of simplicity we took some short-cuts. For example, offering the task back to the queue feels odd, and could probably be avoided. More importantly however, there is a small bug with this implementation.</p>
</div>
<div class="sect2">
<h3 id="_a_bug"><a class="anchor" href="#_a_bug"></a>A bug</h3>
<div class="paragraph">
<p>The previous solution has a race condition. The solution is still very decent, but you probably wouldn&#8217;t want to use it in production. But that is already an assumption on everything we have been doing.</p>
</div>
<div class="paragraph">
<p>Do you want to try to identify the race condition? The tip is: Consider the listing <a href="#firstSeriousSolution">A serious solution</a>, and what would happen if two tasks are scheduled within a very small time-interval, and such that the second task should run before the first task. The discussion is below.</p>
</div>
<div class="paragraph">
<p>Without loss of generality, imagine Task 1 is inserted first, and should run 1 hour from now. Task 2 is inserted second (but very, very shortly after), and it should run 5 minutes from now. From the previous discussion, we expect Task 2 to run first and start running after 5 minutes.<br>
This might or not be the case. Depends on the time interval between the insertion of the two tasks, and the OS scheduling of the timer thread relative to the client threads. In other words, there is a race condition.<br>
The failing scenario is as follows. Imagine the queue is empty and the timer thread is blocked at <code>queue.take()</code>. Task 1 is introduced and the timer thread awakens and proceeds to next line of code. Critically, before the timer thread reaches and acquires the intrinsic lock, another client thread (potentially the same even), inserts Task 2. Task 2 is meant to run sooner. On the <code>schedule</code> method, the client thread enters the synchronised block, and calls <code>notify</code>. However, that is pointless. At that point in time, the timer thread is <strong>not</strong> waiting on the monitor. It hasn&#8217;t yet called obtained the monitor and called <code>object.wait(&lt;timeout&gt;)</code>. When the timer thread enters the synchronised block, Task 2 has already been inserted, and the thread has missed the notification to wake up and to re-compute the timeout to 5 minutes. Hence, the timer thread will wait for 1 full hour, at which point Task 2 is 55 minutes late. Both tasks will still run, and in fact Task 2 will even run before Task 1, but not when it should have.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_cancellation"><a class="anchor" href="#_cancellation"></a>Cancellation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Most people nowadays work in the context of existing web server applications which are meant to run forever. Because we are less exposed to this issue of shutting a system down, its importance is overlooked. However, cancellation and end-of-lifecycle behaviour for a standalone timer (or any executor service) is a critical feature.</p>
</div>
<div class="paragraph">
<p>What do we mean by cancellation? We want the timer to stop running tasks, and for the associated resources to be released, which will mean at least the timer thread terminates. We also want the cancellation to be reliable, predictable, safe. Well, that goes without saying. What those things mean in this context however, is still to be determined.</p>
</div>
<div class="paragraph">
<p>When a client asks for cancellation, the system might be in four major states.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>One task is running, but no more tasks are scheduled.</p>
</li>
<li>
<p>One is running, and additional tasks are scheduled.</p>
</li>
<li>
<p>No task running, and no more tasks scheduled.</p>
</li>
<li>
<p>No task running, but some tasks scheduled.</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/OverviewWithCancellation.svg" alt="OverviewWithCancellation">
</div>
<div class="title">Figure 5. Revisiting the high-level representation. Very useful for the discussion that follows.</div>
</div>
<div class="paragraph">
<p>This raises questions about what to exactly do when cancellation is requested.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Do we try to cancel an actively running task?</p>
<div class="ulist">
<ul>
<li>
<p>Is it even possible to cancel an actively running task?</p>
</li>
</ul>
</div>
</li>
<li>
<p>If yes to above, do we also then run the additional tasks that were already on the queue prior to cancellation?</p>
</li>
<li>
<p>If yes to above, do we then also allow new tasks to be submitted if they are scheduled to run before the last one? (The last one being the latest task at the time of the cancellation request)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Starting in reverse, for question 3, the answer is <strong>no</strong>. For <code>Timer</code> and also for  <code>ScheduledExecutorService</code>. Once cancellation is requested, no more tasks can be added, regardless of their scheduled time to run. Any further submissions result in an exception. We will follow that as well.</p>
</div>
<div class="paragraph">
<p>For question 2, that is up for debate. What would you, as a user, expect?<br>
Turns out, <code>Timer</code> will <strong>not</strong> run any task already scheduled if it is not already running. They are  removed from the queue immediately - when <code>cancel</code> returns, the queue is empty. In contrast, a <code>ScheduledExecutorService</code> has two methods: <code>shutdown()</code> and <code>shutdownNow()</code>. The former runs all queued tasks. If a queued task is scheduled to run in 10 hours, then at least for those 10 hours the service will be running. The latter will discard them. We will follow <code>Timer</code> 's approach.</p>
</div>
<div class="paragraph">
<p>Lastly, regarding any possible task running at the time of cancellation, <code>Timer</code> will not interfere. Meaning it will not even <em>try to cancel</em>  it. The same is true for <code>ScheduledExecutorService#shutdown()</code>. In comparison, <code>shutdownNow()</code> will indeed <em>try to cancel</em>  the task.<br>
The wording <em>try to cancel</em> is appropriate. There is no mechanism in the Java/JVM world to force a running task to stop. There are only cooperative mechanisms. Ultimately it is up to the task (e.g., the <code>Runnable</code> instance) itself to comply.</p>
</div>
<div class="sect2">
<h3 id="_getting_on_with_it"><a class="anchor" href="#_getting_on_with_it"></a>Getting on with it</h3>
<div class="paragraph">
<p>The most straightforward approach is to use a flag; set by the client thread, and read by the timer thread. It must account for the fact that it will be accessed by multiple threads (at least one of the accesses being a write). In this situation, tagging a boolean as <code>volatile</code> would be the least powerful solution. However, because of the way I set up things, the <code>mainLoop()</code> method is not on the same scope as the <code>cancel()</code> method, and makes this awkward. I use <code>AtomicBoolean</code> instead; effectively a more powerful construct than needed.</p>
</div>
<details id="cancellationFirstAttempt">
<summary class="title">Cancellation - First try. Builds on top of previous listing <a href="#firstSeriousSolution">A serious solution</a></summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-diff hljs" data-lang="diff">import java.util.Comparator
+ import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.{BlockingQueue, PriorityBlockingQueue}

class CustomTimer private (
+ shutdown: AtomicBoolean,
  lock: Object,
  queue: BlockingQueue[(Runnable, Long)]
) {

+ def cancel(): Unit = shutdown.set(true)

  def schedule(runnable: Runnable, delay: Long): Unit = {
+   if (shutdown.get()) throw new IllegalArgumentException("Timer already cancelled.")
    val thisTask = (runnable, System.currentTimeMillis() + delay)
    queue.put(thisTask)
    if (queue.peek() == thisTask) {
      lock.synchronized {
        lock.notify()
      }
    }
  }
}

object CustomTimer {

  private def comparator: Comparator[(Runnable, Long)] =
    new Comparator[(Runnable, Long)] {
      def compare(o1: (Runnable, Long), o2: (Runnable, Long)): Int =
        (o1._2 - o2._2).toInt
    }

  def apply(threadName: String): CustomTimer = {
+   val shutdown = new AtomicBoolean(false)
    val lock: Object = new Object()
    val queue = new PriorityBlockingQueue[(Runnable, Long)](10, comparator)

    def mainLoop(): Unit =
-     while (true) {
+     while (!shutdown.get()) {
        val tuple @ (runnableTask, whenToRun) = queue.take()
        val timeToWait = whenToRun - System.currentTimeMillis()
        if (timeToWait &lt;= 0) runnableTask.run()
        else {
          lock.synchronized {
            lock.wait(timeToWait)
          }
          queue.offer(tuple)
        }
      }

    val timerThread = new Thread(new Runnable { def run(): Unit = mainLoop() })
    timerThread.setName(threadName)
    timerThread.setDaemon(false)
    timerThread.start()
-   new CustomTimer(lock, queue)
+   new CustomTimer(shutdown, lock, queue)
  }
}</code></pre>
</div>
</div>
</div>
</details>
<div class="paragraph">
<p>This solution is decent enough, but a slight problem makes it not really fit for production.</p>
</div>
<details>
<summary class="title">Problem 1. Program runs forever.</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">object SomeTests extends App {
  val javaTimer = CustomTimer("FooBarTimer")
  Thread.sleep(1) <i class="conum" data-value="1"></i><b>(1)</b>
  javaTimer.cancel()
} <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This hack <em>tries</em> to ensure the timer thread enters the loop before cancellation is requested. Not core part of the example.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Thread <code>main</code> exits here. What about the other thread of the program?</td>
</tr>
</table>
</div>
</div>
</details>
<div class="paragraph">
<p>The program above would never terminate.<br>
The problem is that if cancellation is requested when the queue is empty - which will definitely happen because a client has no way of knowing the state of the queue - then the timer thread blocks at <code>queue.take()</code>. The thread goes into a waiting state, from which it would not wake up unless a client submitted a new task, namely via the mechanism discussed earlier. Because the JVM does not shutdown until all non-daemon threads have finished, and because our timer thread is non-daemon and is still active (despite being blocked), then the program never terminates. This behaviour would cause enormous confusion in an even small code base.</p>
</div>
<details id="cancellationSecondProblem">
<summary class="title">Problem 2. Program runs for 10 hours and then does not run the task.</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">import scala.concurrent.duration._

object SomeTests extends App {
  val javaTimer = CustomTimer("FooBarTimer")

  javaTimer.schedule(
    new Runnable { def run() = spin(10.second) },
    10.hours.toMillis
  )

  javaTimer.cancel()
}</code></pre>
</div>
</div>
</div>
</details>
<div class="paragraph">
<p>Similarly, and referencing <a href="#cancellationSecondProblem">the code above</a>, if there are still tasks to run when cancellation is requested, then the timer thread might be blocked at <code>lock.wait(timeWait)</code>, waiting to run. In this scenario, the thread only has a chance to see the updated shutdown flag after <code>timeWait</code> expires and then exit the loop, terminating the thread. If <code>timeWait</code> is 10 hours, then the JVM program will exit after 10 hours.<br>
This is similar to what happens for the equivalent method <code>ScheduledThreadPoolExecutor#shutdown()</code> (but not for <code>shutdownNow()</code>). Off course in that case, the thread would wait 10 hours <strong>but</strong> actually run the associated task, which is the documented behaviour for that method; whilst here we would wait 10 hours <strong>and never</strong> run it.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_case_for_threadinterrupt"><a class="anchor" href="#_the_case_for_threadinterrupt"></a>The case for <code>Thread#interrupt()</code></h3>
<div class="paragraph">
<p>The underlying issue in both problems is the call to a blocking method prevents the flag from being read. We could solve the second problem - when the tread is held at <code>lock.wait(timeWait)</code> - with relative ease. The issue there is that after <code>cancel()</code> is called the lock will never wake prematurely. Therefore, we could make <code>cancel()</code> act the same way as <code>schedule()</code>: enter the lock, and then notify the timer thread.</p>
</div>
<details>
<summary class="title">Fixing Problem 1</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">def cancel(): Unit = {
  shutdown.set(true)
  lock.synchronized {
    lock.notify()
  }
}</code></pre>
</div>
</div>
</div>
</details>
<div class="paragraph">
<p>Because now we enter the same lock that the timer thread is waiting one, we are able to wake up the thread prematurely which will then be able to read the updated flag. This is <span class="underline">exactly</span> the approach that <code>Timer</code> takes.<br>
In our case the solution is not fully water-proof though. It only works if the timer thread is <strong>already</strong> blocked at <code>lock.wait(timeWait)</code>. If the timer thread is already inside a loop iteration <strong>but</strong> has not entered the lock yet, then the <code>lock.notify()</code> from the client thread exits before having a chance to wake up the other thread, and we go back to the same problem. This is a race condition. The time window for this to occur is very small, but exists. It can be fixed by making a few smart changes on the <code>mainLoop()</code>. Changes which are present on <code>Timer</code> off course.</p>
</div>
<div class="paragraph">
<p>In any case, this doesn&#8217;t solve the first problem, when the queue is empty, and the timer thread blocked at <code>queue.take()</code>.</p>
</div>
<div class="sect3">
<h4 id="_poison_pills"><a class="anchor" href="#_poison_pills"></a>Poison pills</h4>
<div class="paragraph">
<p>A solution to that problem is to use poison pills.<br>
This concept is a common mechanism for cancellation. In the Java world, and elsewhere. It is not used by <code>Timer</code> though. It consists of an agreement between the clients and the timer thread that a special message signals the cancellation. This message is the <code>Poison Pill</code>. In environments where there are several producers and consumers, it is harder to implement, but for our custom timer, with just one consumer thread (the timer thread), it is quite straightforward.<br>
This approach works because by inserting the poison pill onto the queue upon <code>cancel()</code>, if the timer thread is blocked at <code>queue.take()</code>, it will wake up. This is, off course, the same mechanism discussed earlier on section <a href="#_attempt_2">Attempt 2</a> about scheduling earlier tasks . Additionally, if it isn&#8217;t blocked there, then the thread will exit by the other mechanism anyway.</p>
</div>
<details id="cancellationFixed">
<summary class="title">Cancellation - Fixed</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-diff hljs" data-lang="diff">+ import com.cmhteixeira.concurrent.timer.CustomTimer.PoisonPill
import java.util.Comparator
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.{BlockingQueue, PriorityBlockingQueue}

class CustomTimer private (
  shutdown: AtomicBoolean,
  lock: Object,
  queue: BlockingQueue[(Runnable, Long)]
) {

  def cancel(): Unit = {
    shutdown.set(true)
+   queue.put((PoisonPill, 0))
+   lock.synchronized {
+     lock.notify()
+   }
  }

  def schedule(runnable: Runnable, delay: Long): Unit = {
    if (shutdown.get())
      throw new IllegalArgumentException("Timer already cancelled.")
    val thisTask = (runnable, System.currentTimeMillis() + delay)
    queue.put(thisTask)
    if (queue.peek() == thisTask) {
      lock.synchronized {
        lock.notify()
      }
    }
  }
}

object CustomTimer {

+ private object PoisonPill extends Runnable {
+   override def run(): Unit =
+     throw new RuntimeException("This will never happen.")
+ }

  private def comparator: Comparator[(Runnable, Long)] =
    new Comparator[(Runnable, Long)] {
      def compare(o1: (Runnable, Long), o2: (Runnable, Long)): Int =
        (o1._2 - o2._2).toInt
    }

  def apply(threadName: String): CustomTimer = {
    val shutdown = new AtomicBoolean(false)
    val lock: Object = new Object()
    val queue = new PriorityBlockingQueue[(Runnable, Long)](10, comparator)

    def mainLoop(): Unit =
      while (!shutdown.get()) {
        val tuple @ (runnableTask, whenToRun) = queue.take()
+       if (runnableTask.isInstanceOf[PoisonPill.type]) () <i class="conum" data-value="1"></i><b>(1)</b>
+       else {
          val timeToWait = whenToRun - System.currentTimeMillis()
          if (timeToWait &lt;= 0) runnableTask.run()
          else {
            lock.synchronized {
              lock.wait(timeToWait)
            }
            queue.offer(tuple)
          }
+       }
      }

    val timerThread = new Thread(new Runnable { def run(): Unit = mainLoop() })
    timerThread.setName(threadName)
    timerThread.setDaemon(false)
    timerThread.start()
    new CustomTimer(shutdown, lock, queue)
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If the task is actually a poison pill, then the while iteration finishes immediately, and the while loop breaks because the shutdown flag is also set.</td>
</tr>
</table>
</div>
</div>
</details>
<div class="paragraph">
<p><code>Timer</code> does not use poison pills. As it uses a custom-made queue (namely <code>java.util.TaskQueue</code> on the same file as <code>java.util.Timer</code>), which it locks explicitly the same was way we lock our <code>lock</code> object, it is able to solve the first problem and the second problem in one go only, like we do for problem 1.</p>
</div>
<div class="paragraph">
<p>With the code <a href="#cancellationFixed">above</a>, we achieve a respectable timer/scheduled-service. It is rough around the edges, with at least one race condition, but still fundamentally sound. All this in a fraction of the lines of code.</p>
</div>
</div>
<div class="sect3">
<h4 id="_thread_interruption"><a class="anchor" href="#_thread_interruption"></a>Thread interruption</h4>
<div class="paragraph">
<p>There is an alternative solution to the problem: Thread interruption.<br>
Thread interruption is a common way to implement cancellation on the JVM. <code>Timer</code> does not use it but the <code>ScheduledExecutorService</code> (and related <code>java.util.concurrent.ThreadPoolExecutor</code>) do use it to implement the <code>shutdownNow()</code> functionality.<br>
In a way, this approach is more interesting than <a href="#_poison_pills">Poison pills</a>. Poison pills are language agnostic, and does not leverage any peculiarities of the JVM itself. With thread interrupts we have an excuse to study a relatively unknown behaviour of Java, which is off course important for a Java/Scala/JVM developer studying concurrency, as this can be regarded as a primitive.</p>
</div>
<div class="paragraph">
<p>Java Threads have three methods that a client holding a reference to a <code>Thread</code> object (often referred to as thread handle) can call:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. JVM Threads</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Thread {
    public void interrupt() {/* impl */}
    public boolean isInterrupted() {/* impl */}
    public static boolean interrupted() {/* impl */}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Here is the important part. The JVM&#8217;s  documented behaviour states that when a given thread is blocked at <em>native blocking</em> methods, such as <code>Object#wait()</code>, and some other different thread calls <code>interrupt()</code> on the former, then the underlying system (i.e., the JVM) can detect it and is able to wake-up the former thread, throwing a <code>InterruptedException</code>.</p>
</div>
<div class="paragraph">
<p>This behaviour solves both problems at once.<br>
On the first problem, the timer thread is blocked at <code>lock.wait(&lt;timeWaiting&gt;)</code>. Therefore, if another thread gets hold of the timer thread&#8217;s handle, and calls <code>interrupt()</code> we can expect the timer thread will wake-up and then throw an exception. We can catch that exception and proceed with cancellation.</p>
</div>
<div class="paragraph">
<p>On the second problem, the timer thread is blocked at <code>queue.take()</code>. Now, this is not one of the naive methods documented for interrupts. However, the documentation on the priority queue that we are using reads:</p>
</div>
<div class="quoteblock">
<div class="title">Java docs for method <code>take()</code> of <code>java.util.concurrent.BlockingQueue&lt;E&gt;</code>.</div>
<blockquote>
<div class="paragraph">
<p>/*<br>
* Retrieves and removes the head of this queue, waiting if necessary<br>
* until an element becomes available.<br>
*<br>
* @return the head of this queue<br>
* <strong>@throws InterruptedException if interrupted while waiting</strong><br>
*/<br>
E take() throws InterruptedException;</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>We can be sure that in this scenario the timer thread will also wake-up and throw an exception. If we were to explore how <code>PriorityBlockingQueue</code> is able to guarantee the <code>InterruptedException</code> is thrown when the thread is interrupted we would conclude that eventually it is making a call to a native method (e.g., <code>Object#wait()</code>) as well, and therefore ultimately relying on the very same mechanism. This highlights the importance of studying low-level mechanisms. All other libraries must ultimately rely on them.</p>
</div>
<details id="cancellationFixedWithInterrupts">
<summary class="title">Cancellation - Fixed with Thread interrupts</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-diff hljs" data-lang="diff">import java.util.Comparator
- import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.{BlockingQueue, PriorityBlockingQueue}

class CustomTimer private (
- shutdown: AtomicBoolean,
+ threadHandle: Thread,
  lock: Object,
  queue: BlockingQueue[(Runnable, Long)]
) {

- def cancel(): Unit = shutdown.set(true)
+ def cancel(): Unit = threadHandle.interrupt()

  def schedule(runnable: Runnable, delay: Long): Unit = {
-   if (shutdown.get())
+   if (threadHandle.isInterrupted || !threadHandle.isAlive)
      throw new IllegalArgumentException("Timer already cancelled.")
    val thisTask = (runnable, System.currentTimeMillis() + delay)
    queue.put(thisTask)
    if (queue.peek() == thisTask) {
      lock.synchronized {
        lock.notify()
      }
    }
  }
}

object CustomTimer {

  private def comparator: Comparator[(Runnable, Long)] =
    new Comparator[(Runnable, Long)] {
      def compare(o1: (Runnable, Long), o2: (Runnable, Long)): Int =
        (o1._2 - o2._2).toInt
    }

  def apply(threadName: String): CustomTimer = {
-   val shutdown = new AtomicBoolean(false)
    val lock: Object = new Object()
    val queue = new PriorityBlockingQueue[(Runnable, Long)](10, comparator)

    def mainLoop(): Unit = {
+     try {
-       while (!shutdown.get()) {
+       while (!Thread.currentThread().isInterrupted) {
          val tuple @ (runnableTask, whenToRun) = queue.take()
          val timeToWait = whenToRun - System.currentTimeMillis()
          if (timeToWait &lt;= 0) runnableTask.run()
          else {
            lock.synchronized {
              lock.wait(timeToWait)
            }
            queue.offer(tuple)
          }
        }
+     } catch {
+         case _: InterruptedException =&gt; ()
+     } finally {
+       queue.clear()
+     }
    }

    val timerThread = new Thread(new Runnable { def run(): Unit = mainLoop() })
    timerThread.setName(threadName)
    timerThread.setDaemon(false)
    timerThread.start()
-   new CustomTimer(shutdown, lock, queue)
+   new CustomTimer(timerThread, lock, queue)
  }
}</code></pre>
</div>
</div>
</div>
</details>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
On the listing above, <code>schedule()</code> checks <code>threadHandle.isInterrupted || !threadHandle.isAlive</code>. Why is the first condition not sufficient? It turns out that when a thread is no longer running the JVM specification does not explicitly define <code>isInterruped()</code> should return true, and some implementations of it (namely openJDK, and Oracle) return false. So that extra check might or might not be needed. It&#8217;s definitely not needed after Java 14, where the behaviour was finally corrected.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_common_issues"><a class="anchor" href="#_common_issues"></a>Common issues</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_delayed_tasks"><a class="anchor" href="#_delayed_tasks"></a>Delayed Tasks</h3>
<div class="paragraph">
<p>Because <code>Timer</code> and our custom timer only have one thread, if a task takes to long, the remaining tasks will not execute when they should. This should be self-evident from the previous detailed analysis.</p>
</div>
<details id="delayExecutionOfTask">
<summary class="title">Delay of execution of a task. See illustration <a href="#delayExecutionOfTaskImage">below</a>.</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">import java.util.{Timer, TimerTask}
import scala.concurrent.duration._

object SomeTests extends App {

  val javaTimer = new Timer("FooBarTimer")

  javaTimer.schedule(
    new TimerTask { def run() = spin(70.second) },
    10.second.toMillis
  )

  javaTimer.schedule(
    new TimerTask { def run() = spin(20.second) },
    30.second.toMillis
  )
}</code></pre>
</div>
</div>
</div>
</details>
<div id="delayExecutionOfTaskImage" class="imageblock">
<div class="content">
<img src="_images/TimerThreadLane_DelayedTask.svg" alt="TimerThreadLane DelayedTask">
</div>
<div class="title">Figure 6. Thread states of a <code>java.util.Timer</code> for the listing <a href="#delayExecutionOfTask">above</a>. Task2 starts running after the intended time. Similar result using the custom timer.</div>
</div>
<div class="paragraph">
<p>The <code>ScheduledThreadPoolExecutor</code> lessens this problem by having multiple threads that can pick up tasks. <em>Lessens</em> is the appropriate word, as the problem is not fully solved.<br>
If the clients submit more tasks than there are threads, <strong>and</strong> each of these takes longer to run than the next is due, some task will start running later than intended.</p>
</div>
<div class="paragraph">
<p>This shortcoming is why <code>Timer</code> (and similarly for <code>ScheduledThreadPoolExecutor</code>) has two similar methods for scheduling periodic tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>schedule(&lt;task&gt;, &lt;delay&gt;, &lt;period&gt;)</code></p>
</li>
<li>
<p><code>scheduleAtFixedRate(&lt;task&gt;, &lt;delay&gt;, &lt;period&gt;)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For the first, the <code>period</code> represents the time that should elapse between the end of one execution, to the beginning of the next execution of the task.<br>
For the second, the <code>period</code> represents the frequency (i.e., rate) at which the task should run.<br>
These two concepts are <strong>not</strong> equivalent in the scenario where the thread is busy running other tasks and starts running the task later than it should. For example, if we schedule a task to run every 1 minute, and the thread is currently busy running a task that takes 1 hour, then after that hour, in the first case, our task runs only once (and every minute thereafter), whilst on the second case it runs 60 times to keep up.</p>
</div>
<div class="paragraph">
<p>While it is useful to know this, it is mostly irrelevant to the current analysis. We only care about the concurrency fundamentals of <code>Timer</code>. Once that is known, the remaining behaviour is a matter of time, and thinking a bit harder about corner cases.</p>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions_destroy_the_timer"><a class="anchor" href="#_exceptions_destroy_the_timer"></a>Exceptions destroy the timer</h3>
<div class="paragraph">
<p>When a task being executed by <code>Timer</code> throws an exception, the thread dies, and the <code>Timer</code> itself behaves as if it had been cancelled; meaning no more tasks can be scheduled. In contrast, <code>ScheduledThreadPoolExecutor</code> takes a more defensive approach, and is able to recuperate and continue running normally.<br>
On our <a href="#cancellationFirstAttempt">current solution</a>, given that there is no <code>try/catch</code> block in sight, it&#8217;s clear that our thread will exit as well. Our offense is that we have no mechanism to stop any further task submissions. Less concerning, but also bad, is the fact that we don&#8217;t remove the tasks on the queue; these will never be run, and are obsolete references.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_final_comparison"><a class="anchor" href="#_final_comparison"></a>Final comparison</h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Cherry-picked comparison points between the <code>Timer</code> and the timer we have developed</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top"><code>java.util.Timer</code></th>
<th class="tableblock halign-left valign-top">Our custom timer</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of threads</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Thread created upon instantiation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">‚úì</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">‚úì</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Thread started upon instantiation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">‚úì</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">‚úì</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Shared data structure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bespoke binary queue w/ locking</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Existing blocking priority queue</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Relies on <code>Object#wait(&lt;timeout&gt;)</code> for scheduling?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">‚úì</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">‚úì</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Object used for locking</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses the queue directly.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specific object, created with that objective</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Relies on <code>System.currentTimeMillis()</code>?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">‚úì</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">‚úì</p></td>
</tr>
</tbody>
</table>
</div>
</div>
    <h2 class="page">Comments</h2>
  <p class="comment-note">
    Do you want to share feedback, discuss further ideas, or note errors ? Feel free to leave a comment here! </p>
  <div class="giscus">
  </div>
  <script src="https://giscus.app/client.js" data-repo="cmhteixeira/concurrency-deep-dives" data-repo-id="R_kgDOGsOmkg"
    data-mapping="number" data-term="2" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom"
    data-theme="preferred_color_scheme" data-lang="en" crossorigin="anonymous" async>
    </script>

</article><aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<script>window.uiRootPath = '../_'</script>
<script async src="../_/js/vendor/asciinema-player.min.js"></script>
<script src="../_/js/vendor/highlight.min.js"></script>
<script src="../_/js/vendor/libs.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="../_/js/site.js"></script>

<script>
  // var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights@1.7.1";
  //
  // !function (e, a, t, n, s, i, c) {
  //   e.AlgoliaAnalyticsObject = s, e[s] = e[s] || function () {
  //     (e[s].queue = e[s].queue || []).push(arguments)
  //   }, i = a.createElement(t), c = a.getElementsByTagName(t)[0],
  //     i.async = 1, i.src = n, c.parentNode.insertBefore(i, c)
  // }(window, document, "script", ALGOLIA_INSIGHTS_SRC, "aa");
</script>

<script type="text/javascript">
  docsearch({
    container: '#docsearch',
    appId: 'LWD25NX3CD',
    apiKey: '6408f799f329e3a010e6a5ac397210d8',
    indexName: 'bonitasoft',
    hitsPerPage: 20,
    searchParameters: {
      facetFilters: ["version:master", "tags:concurrency"],
    }
  });
  /*
          docsearch({
          algoliaOptions: {
              clickAnalytics: true,
          },
          handleSelected: function (input, event, suggestion, datasetNumber, context) {
              sendClickEvent(lastQueryID, lastQueryHits, suggestion);
              input.setVal('');
              window.location.assign(suggestion.url);
          },
          queryDataCallback: function (data) {
              lastQueryID = data.results[0].queryID;
              lastQueryHits = data.results[0].hits;
          }
          });

          aa('init', {
          appId: 'BH4D9OD16A',
          apiKey: '16267f96d135c47df8454efd5b448c9a',
          });
      */
</script>

<script>
  // init toggle state
  if (localStorage.getItem('theme') === 'dark') {
    document.getElementById('check').checked = true
    document.getElementById('check-mobile').checked = true
  } else {
    document.getElementById('check').checked = false
    document.getElementById('check-mobile').checked = false
  }
</script>
  </body>
</html>
